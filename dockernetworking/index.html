<!doctype html><html lang=en>
<head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=robots content="noodp">
<meta http-equiv=x-ua-compatible content="IE=edge, chrome=1">
<title>Getting started with Docker Networking - Boyang Yan's Tech Blog</title><meta name=description content="This is Boyang Yan's Tech Blog"><meta property="og:title" content="Getting started with Docker Networking">
<meta property="og:description" content="Networking Overview One of the reasons Docker containers and services are so powerful is that you can connect them together, or connect them to non-Docker workloads. Docker containers and services do not even need to be aware that they are deployed on Docker, or whether their peers are also Docker workloads or not. Whether your Docker hosts run Linux, Windows, or a mix of the two, you can use Docker to manage them in a platform-agnostic way.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://yanboyang.com/dockernetworking/"><meta property="og:image" content="https://yanboyang.com/logo.png"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2020-01-05T06:11:32+10:00">
<meta property="article:modified_time" content="2021-12-12T09:45:53+00:00">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://yanboyang.com/logo.png">
<meta name=twitter:title content="Getting started with Docker Networking">
<meta name=twitter:description content="Networking Overview One of the reasons Docker containers and services are so powerful is that you can connect them together, or connect them to non-Docker workloads. Docker containers and services do not even need to be aware that they are deployed on Docker, or whether their peers are also Docker workloads or not. Whether your Docker hosts run Linux, Windows, or a mix of the two, you can use Docker to manage them in a platform-agnostic way.">
<meta name=application-name content="LoveIt">
<meta name=apple-mobile-web-app-title content="LoveIt"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=https://yanboyang.com/favicon.ico>
<link rel=icon type=image/png sizes=32x32 href=https://yanboyang.com/favicon-32x32.png>
<link rel=icon type=image/png sizes=16x16 href=https://yanboyang.com/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=https://yanboyang.com/apple-touch-icon.png><link rel=mask-icon href=https://yanboyang.com/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=https://yanboyang.com/site.webmanifest><link rel=canonical href=https://yanboyang.com/dockernetworking/><link rel=prev href=https://yanboyang.com/wechat/><link rel=next href=https://yanboyang.com/acr/><link rel=stylesheet href=https://yanboyang.com/lib/normalize/normalize.min.css><link rel=stylesheet href=https://yanboyang.com/css/style.min.css><link rel=stylesheet href=https://yanboyang.com/lib/fontawesome-free/all.min.css><link rel=stylesheet href=https://yanboyang.com/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Getting started with Docker Networking","inLanguage":"en","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/yanboyang.com\/dockernetworking\/"},"genre":"posts","keywords":"Docker, Networking","wordcount":6023,"url":"https:\/\/yanboyang.com\/dockernetworking\/","datePublished":"2020-01-05T06:11:32+10:00","dateModified":"2021-12-12T09:45:53+00:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"Boyang Yan"},"description":""}</script></head>
<body header-desktop=fixed header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem('theme')?localStorage.getItem('theme')==='dark':'auto'==='auto'?window.matchMedia('(prefers-color-scheme: dark)').matches:'auto'==='dark')&&document.body.setAttribute('theme','dark')</script>
<div id=mask></div><div class=wrapper><header class=desktop id=header-desktop>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-101949995-1','auto'),ga('send','pageview'))</script>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','UA-101949995-1','auto'),ga('send','pageview'))</script>
<script async src=https://www.google-analytics.com/analytics.js></script>
<div class=header-wrapper>
<div class=header-title>
<a href=https://yanboyang.com/ title="Boyang Yan's Tech Blog"></a>
</div>
<div class=menu>
<div class=menu-inner><a class=menu-item href=https://yanboyang.com/> Home </a><a class=menu-item href=https://yanboyang.com/posts/> Posts </a><a class=menu-item href=https://yanboyang.com/tags/> Tags </a><a class=menu-item href=https://yanboyang.com/categories/> Categories </a><a class=menu-item href=https://yanboyang.com/about/> About Me </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop>
<input type=text placeholder="Search titles or contents..." id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=Search>
<i class="fas fa-search fa-fw"></i>
</a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=Clear>
<i class="fas fa-times-circle fa-fw"></i>
</a>
<span class="search-button search-loading" id=search-loading-desktop>
<i class="fas fa-spinner fa-fw fa-spin"></i>
</span>
</span><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw"></i>
</a>
</div>
</div>
</div>
</header><header class=mobile id=header-mobile>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-101949995-1','auto'),ga('send','pageview'))</script>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','UA-101949995-1','auto'),ga('send','pageview'))</script>
<script async src=https://www.google-analytics.com/analytics.js></script>
<div class=header-container>
<div class=header-wrapper>
<div class=header-title>
<a href=https://yanboyang.com/ title="Boyang Yan's Tech Blog"></a>
</div>
<div class=menu-toggle id=menu-toggle-mobile>
<span></span><span></span><span></span>
</div>
</div>
<div class=menu id=menu-mobile><div class=search-wrapper>
<div class="search mobile" id=search-mobile>
<input type=text placeholder="Search titles or contents..." id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=Search>
<i class="fas fa-search fa-fw"></i>
</a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=Clear>
<i class="fas fa-times-circle fa-fw"></i>
</a>
<span class="search-button search-loading" id=search-loading-mobile>
<i class="fas fa-spinner fa-fw fa-spin"></i>
</span>
</div>
<a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>
Cancel
</a>
</div><a class=menu-item href=https://yanboyang.com/ title>Home</a><a class=menu-item href=https://yanboyang.com/posts/ title>Posts</a><a class=menu-item href=https://yanboyang.com/tags/ title>Tags</a><a class=menu-item href=https://yanboyang.com/categories/ title>Categories</a><a class=menu-item href=https://yanboyang.com/about/ title>About Me</a><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw"></i>
</a></div>
</div>
</header>
<div class="search-dropdown desktop">
<div id=search-dropdown-desktop></div>
</div>
<div class="search-dropdown mobile">
<div id=search-dropdown-mobile></div>
</div>
<main class=main>
<div class=container><div class=toc id=toc-auto>
<h2 class=toc-title>Contents</h2>
<div class=toc-content id=toc-content-auto></div>
</div><article class="page single"><h1 class="single-title animated flipInX">Getting started with Docker Networking</h1><div class=post-meta>
<div class=post-meta-line><span class=post-author><a href=https://yanboyang.com/ title=Author rel=author class=author><i class="fas fa-user-circle fa-fw"></i>Boyang Yan</a></span>&nbsp;<span class=post-category>included in <a href=https://yanboyang.com/categories/networking/><i class="far fa-folder fa-fw"></i>Networking</a></span></div>
<div class=post-meta-line><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2020-01-05>2020-01-05</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;6023 words&nbsp;
<i class="far fa-clock fa-fw"></i>&nbsp;29 minutes&nbsp;</div>
</div><div class="details toc" id=toc-static kept=true>
<div class="details-summary toc-title">
<span>Contents</span>
<span><i class="details-icon fas fa-angle-right"></i></span>
</div>
<div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents>
<ul>
<li><a href=#networking-overview>Networking Overview</a></li>
<li><a href=#network-drivers>Network drivers</a>
<ul>
<li><a href=#bridge>Bridge</a>
<ul>
<li><a href=#differences-between-user-defined-bridges-and-the-default-bridge>Differences between user-defined bridges and the default bridge</a></li>
<li><a href=#manage-a-user-defined-bridge>Manage a user-defined bridge</a></li>
<li><a href=#connect-a-container-to-a-user-defined-bridge>Connect a container to a user-defined bridge</a></li>
<li><a href=#disconnect-a-container-from-a-user-defined-bridge>Disconnect a container from a user-defined bridge</a></li>
<li><a href=#use-ipv6>Use IPv6</a></li>
<li><a href=#enable-forwarding-from-docker-containers-to-the-outside-world>Enable forwarding from Docker containers to the outside world</a></li>
<li><a href=#use-the-default-bridge-network>Use the default bridge network</a></li>
<li><a href=#connect-a-container-to-the-default-bridge-network>Connect a container to the default bridge network</a></li>
<li><a href=#configure-the-default-bridge-network>Configure the default bridge network</a></li>
<li><a href=#use-ipv6-with-the-default-bridge-network>Use IPv6 with the default bridge network</a></li>
</ul>
</li>
<li><a href=#host>Host</a></li>
<li><a href=#overlay>Overlay</a>
<ul>
<li><a href=#docker-swarm>Docker Swarm</a>
<ul>
<li><a href=#whats-docker-swarm>What&rsquo;s Docker Swarm?</a></li>
<li><a href=#what-is-docker-swarm-used-for>What is Docker Swarm used for?</a></li>
</ul>
</li>
<li><a href=#whats-an-overlay-network>What&rsquo;s an overlay network?</a></li>
<li><a href=#prerequisites>Prerequisites</a></li>
<li><a href=#use-the-default-overlay-network>Use the default overlay network</a>
<ul>
<li><a href=#prerequisites-1>Prerequisites</a></li>
<li><a href=#walkthrough>Walkthrough</a>
<ul>
<li><a href=#create-the-swarm>Create the swarm</a></li>
<li><a href=#create-the-services>Create the services</a></li>
</ul>
</li>
</ul>
</li>
<li><a href=#use-a-user-defined-overlay-network>Use a user-defined overlay network</a>
<ul>
<li><a href=#prerequisites-2>Prerequisites</a></li>
<li><a href=#walkthrough-1>Walkthrough</a></li>
</ul>
</li>
<li><a href=#use-an-overlay-network-for-standalone-containers>Use an overlay network for standalone containers</a>
<ul>
<li><a href=#prerequisites-3>Prerequisites</a></li>
<li><a href=#walk-through>Walk-through</a></li>
</ul>
</li>
<li><a href=#communicate-between-a-container-and-a-swarm-service>Communicate between a container and a swarm service</a></li>
</ul>
</li>
<li><a href=#macvlan>Macvlan</a>
<ul>
<li><a href=#create-a-macvlan-network>Create a macvlan network</a>
<ul>
<li><a href=#bridge-mode>Bridge mode</a></li>
<li><a href=#8021q-trunk-bridge-mode>802.1q trunk bridge mode</a></li>
<li><a href=#use-an-ipvlan-instead-of-macvlan>Use an ipvlan instead of macvlan</a></li>
<li><a href=#use-ipv6-1>Use IPv6</a></li>
</ul>
</li>
</ul>
</li>
<li><a href=#none>None</a></li>
<li><a href=#network-plugins>Network plugins</a></li>
</ul>
</li>
</ul>
</nav></div>
</div><div class=content id=content><h2 id=networking-overview>Networking Overview</h2>
<p>One of the reasons Docker containers and services are so powerful is that you can connect them together, or connect them to non-Docker workloads. Docker containers and services do not even need to be aware that they are deployed on Docker, or whether their peers are also Docker workloads or not. Whether your Docker hosts run Linux, Windows, or a mix of the two, you can use Docker to manage them in a platform-agnostic way.</p>
<p>Docker comes with three networking drivers by default. Network adapters are also initialized using these drivers, carrying the same exact name. For example, if you run docker network ls you will see a network named bridge, this driver uses bridge networking driver. This is the default network to which every container will try and connect, unless specified otherwise.</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-console data-lang=console><span class=go>boyang:~$ docker network ls
</span><span class=go>NETWORK ID          NAME                                DRIVER              SCOPE
</span><span class=go>9180da752799        bridge                              bridge              local
</span><span class=go>67c7f5587624        host                                host                local
</span><span class=go>d15c7dd51668        none                                null                local
</span></code></pre></td></tr></table>
</div>
</div><p>This topic defines some basic Docker networking concepts and prepares you to design and deploy your applications to take full advantage of these capabilities.</p>
<h2 id=network-drivers>Network drivers</h2>
<p>Docker’s networking subsystem is pluggable, using drivers. Several drivers exist by default, and provide core networking functionality:</p>
<h3 id=bridge>Bridge</h3>
<p>The default network driver. If you don’t specify a driver, this is the type of network you are creating. Bridge networks are usually used when your applications run in standalone containers that need to communicate. See bridge networks.</p>
<p>In terms of networking, a bridge network is a Link Layer device which forwards traffic between network segments. A bridge can be a hardware device or a software device running within a host machine’s kernel.</p>
<p>In terms of Docker, a bridge network uses a software bridge which allows containers connected to the same bridge network to communicate, while providing isolation from containers which are not connected to that bridge network. The Docker bridge driver automatically installs rules in the host machine so that containers on different bridge networks cannot communicate directly with each other.</p>
<p>Bridge networks apply to containers running on the same Docker daemon host. For communication among containers running on different Docker daemon hosts, you can either manage routing at the OS level, or you can use an overlay network.</p>
<p>When you start Docker, a default bridge network (also called bridge) is created automatically, and newly-started containers connect to it unless otherwise specified. You can also create user-defined custom bridge networks. User-defined bridge networks are superior to the default bridge network.</p>
<h4 id=differences-between-user-defined-bridges-and-the-default-bridge>Differences between user-defined bridges and the default bridge</h4>
<ul>
<li><strong>User-defined bridges provide automatic DNS resolution between containers.</strong>
Containers on the default bridge network can only access each other by IP addresses, unless you use the &ndash;link option, which is considered legacy. On a user-defined bridge network, containers can resolve each other by name or alias.</li>
</ul>
<p>Imagine an application with a web front-end and a database back-end. If you call your containers web and db, the web container can connect to the db container at db, no matter which Docker host the application stack is running on.</p>
<p>If you run the same application stack on the default bridge network, you need to manually create links between the containers (using the legacy &ndash;link flag). These links need to be created in both directions, so you can see this gets complex with more than two containers which need to communicate. Alternatively, you can manipulate the /etc/hosts files within the containers, but this creates problems that are difficult to debug.</p>
<ul>
<li><strong>User-defined bridges provide better isolation.</strong></li>
</ul>
<p>All containers without a &ndash;network specified, are attached to the default bridge network. This can be a risk, as unrelated stacks/services/containers are then able to communicate.</p>
<p>Using a user-defined network provides a scoped network in which only containers attached to that network are able to communicate.</p>
<ul>
<li><strong>Containers can be attached and detached from user-defined networks on the fly.</strong></li>
</ul>
<p>During a container’s lifetime, you can connect or disconnect it from user-defined networks on the fly. To remove a container from the default bridge network, you need to stop the container and recreate it with different network options.</p>
<ul>
<li><strong>Each user-defined network creates a configurable bridge.</strong></li>
</ul>
<p>If your containers use the default bridge network, you can configure it, but all the containers use the same settings, such as MTU and iptables rules. In addition, configuring the default bridge network happens outside of Docker itself, and requires a restart of Docker.</p>
<p>User-defined bridge networks are created and configured using <em><strong>docker network create</strong></em>. If different groups of applications have different network requirements, you can configure each user-defined bridge separately, as you create it.</p>
<ul>
<li><strong>Linked containers on the default bridge network share environment variables.</strong></li>
</ul>
<p>Originally, the only way to share environment variables between two containers was to link them using the &ndash;link flag. This type of variable sharing is not possible with user-defined networks. However, there are superior ways to share environment variables. A few ideas:</p>
<pre><code>+ Multiple containers can mount a file or directory containing the shared information, using a Docker volume.

+ Multiple containers can be started together using docker-compose and the compose file can define the shared variables.

+ You can use swarm services instead of standalone containers, and take advantage of shared secrets and configs.
</code></pre>
<p>Containers connected to the same user-defined bridge network effectively expose all ports to each other. For a port to be accessible to containers or non-Docker hosts on different networks, that port must be published using the -p or &ndash;publish flag.</p>
<h4 id=manage-a-user-defined-bridge>Manage a user-defined bridge</h4>
<p>Use the docker network create command to create a user-defined bridge network.</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-console data-lang=console><span class=gp>$ </span>docker network create my-net
</code></pre></td></tr></table>
</div>
</div><p>You can specify the subnet, the IP address range, the gateway, and other options. See the docker network create reference or the output of <em><strong>docker network create &ndash;help</strong></em> for details.</p>
<p>Use the docker network rm command to remove a user-defined bridge network. If containers are currently connected to the network, disconnect them first.</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-console data-lang=console><span class=gp>$ </span>docker network rm my-net
</code></pre></td></tr></table>
</div>
</div><p><strong>What’s really happening?</strong>
When you create or remove a user-defined bridge or connect or disconnect a container from a user-defined bridge, Docker uses tools specific to the operating system to manage the underlying network infrastructure (such as adding or removing bridge devices or configuring iptables rules on Linux). These details should be considered implementation details. Let Docker manage your user-defined networks for you.</p>
<h4 id=connect-a-container-to-a-user-defined-bridge>Connect a container to a user-defined bridge</h4>
<p>When you create a new container, you can specify one or more &ndash;network flags. This example connects a Nginx container to the my-net network. It also publishes port 80 in the container to port 8080 on the Docker host, so external clients can access that port. Any other container connected to the my-net network has access to all ports on the my-nginx container, and vice versa.</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-console data-lang=console><span class=gp>$ </span>docker create --name my-nginx <span class=se>\
</span><span class=se></span><span class=go>  --network my-net \
</span><span class=go>  --publish 8080:80 \
</span><span class=go>  nginx:latest
</span></code></pre></td></tr></table>
</div>
</div><p>To connect a running container to an existing user-defined bridge, use the docker network connect command. The following command connects an already-running my-nginx container to an already-existing my-net network:</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-console data-lang=console><span class=gp>$ </span>docker network connect my-net my-nginx
</code></pre></td></tr></table>
</div>
</div><h4 id=disconnect-a-container-from-a-user-defined-bridge>Disconnect a container from a user-defined bridge</h4>
<p>To disconnect a running container from a user-defined bridge, use the docker network disconnect command. The following command disconnects the my-nginx container from the my-net network.</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-console data-lang=console><span class=gp>$ </span>docker network disconnect my-net my-nginx
</code></pre></td></tr></table>
</div>
</div><h4 id=use-ipv6>Use IPv6</h4>
<p>If you need IPv6 support for Docker containers, you need to enable the option on the Docker daemon and reload its configuration, before creating any IPv6 networks or assigning containers IPv6 addresses.</p>
<p>When you create your network, you can specify the &ndash;ipv6 flag to enable IPv6. You can’t selectively disable IPv6 support on the default bridge network.</p>
<h4 id=enable-forwarding-from-docker-containers-to-the-outside-world>Enable forwarding from Docker containers to the outside world</h4>
<p>By default, traffic from containers connected to the default bridge network is not forwarded to the outside world. To enable forwarding, you need to change two settings. These are not Docker commands and they affect the Docker host’s kernel.</p>
<ol>
<li>Configure the Linux kernel to allow IP forwarding.</li>
</ol>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-console data-lang=console><span class=gp>$ </span>sysctl net.ipv4.conf.all.forwarding<span class=o>=</span><span class=m>1</span>
</code></pre></td></tr></table>
</div>
</div><ol start=2>
<li>Change the policy for the iptables FORWARD policy from DROP to ACCEPT.</li>
</ol>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-console data-lang=console><span class=gp>$ </span>sudo iptables -P FORWARD ACCEPT
</code></pre></td></tr></table>
</div>
</div><p>These settings do not persist across a reboot, so you may need to add them to a start-up script.</p>
<h4 id=use-the-default-bridge-network>Use the default bridge network</h4>
<p>The default bridge network is considered a legacy detail of Docker and is not recommended for production use. Configuring it is a manual operation, and it has technical shortcomings.</p>
<h4 id=connect-a-container-to-the-default-bridge-network>Connect a container to the default bridge network</h4>
<p>If you do not specify a network using the &ndash;network flag, and you do specify a network driver, your container is connected to the default bridge network by default. Containers connected to the default bridge network can communicate, but only by IP address, unless they are linked using the legacy &ndash;link flag.</p>
<h4 id=configure-the-default-bridge-network>Configure the default bridge network</h4>
<p>To configure the default bridge network, you specify options in daemon.json. Here is an example daemon.json with several options specified. Only specify the settings you need to customize.</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback>{
  &#34;bip&#34;: &#34;192.168.1.5/24&#34;,
  &#34;fixed-cidr&#34;: &#34;192.168.1.5/25&#34;,
  &#34;fixed-cidr-v6&#34;: &#34;2001:db8::/64&#34;,
  &#34;mtu&#34;: 1500,
  &#34;default-gateway&#34;: &#34;10.20.1.1&#34;,
  &#34;default-gateway-v6&#34;: &#34;2001:db8:abcd::89&#34;,
  &#34;dns&#34;: [&#34;10.20.1.2&#34;,&#34;10.20.1.3&#34;]
}
</code></pre></td></tr></table>
</div>
</div><p>Restart Docker for the changes to take effect.</p>
<h4 id=use-ipv6-with-the-default-bridge-network>Use IPv6 with the default bridge network</h4>
<p>If you configure Docker for IPv6 support (see Use IPv6), the default bridge network is also configured for IPv6 automatically. Unlike user-defined bridges, you can’t selectively disable IPv6 on the default bridge.</p>
<h3 id=host>Host</h3>
<p>For standalone containers, remove network isolation between the container and the Docker host, and use the host’s networking directly. See use the host network.</p>
<p>If you use the host network mode for a container, that container’s network stack is not isolated from the Docker host (the container shares the host’s networking namespace), and the container does not get its own IP-address allocated. For instance, if you run a container which binds to port 80 and you use host networking, the container’s application is available on port 80 on the host’s IP address.</p>
<p><strong>Note:</strong>
Given that the container does not have its own IP-address when using host mode networking, port-mapping does not take effect, and the -p, &ndash;publish, -P, and &ndash;publish-all option are ignored, producing a warning instead:</p>
<p>WARNING: Published ports are discarded when using host network mode</p>
<p>Host mode networking can be useful to optimize performance, and in situations where a container needs to handle a large range of ports, as it does not require network address translation (NAT), and no “userland-proxy” is created for each port.</p>
<p>The host networking driver only works on Linux hosts, and is not supported on Docker Desktop for Mac, Docker Desktop for Windows, or Docker EE for Windows Server.</p>
<p>You can also use a host network for a swarm service, by passing &ndash;network host to the docker service create command. In this case, control traffic (traffic related to managing the swarm and the service) is still sent across an overlay network, but the individual swarm service containers send data using the Docker daemon’s host network and ports. This creates some extra limitations. For instance, if a service container binds to port 80, only one service container can run on a given swarm node.</p>
<h3 id=overlay>Overlay</h3>
<p>Overlay networks connect multiple Docker daemons together and enable swarm services to communicate with each other. You can also use overlay networks to facilitate communication between a swarm service and a standalone container, or between two standalone containers on different Docker daemons. This strategy removes the need to do OS-level routing between these containers. See overlay networks.</p>
<h4 id=docker-swarm>Docker Swarm</h4>
<h5 id=whats-docker-swarm>What&rsquo;s Docker Swarm?</h5>
<p>A Docker Swarm is a group of either physical or virtual machines that are running the Docker application and that have been configured to join together in a cluster. Once a group of machines have been clustered together, you can still run the Docker commands that you&rsquo;re used to, but they will now be carried out by the machines in your cluster. The activities of the cluster are controlled by a swarm manager, and machines that have joined the cluster are referred to as nodes.</p>
<h5 id=what-is-docker-swarm-used-for>What is Docker Swarm used for?</h5>
<p>Docker swarm is a container orchestration tool, meaning that it allows the user to manage multiple containers deployed across multiple host machines.</p>
<p>One of the key benefits associated with the operation of a docker swarm is the high level of availability offered for applications. In a docker swarm, there are typically several worker nodes and at least one manager node that is responsible for handling the worker nodes' resources efficiently and ensuring that the cluster operates efficiently.</p>
<h4 id=whats-an-overlay-network>What&rsquo;s an overlay network?</h4>
<p>An <em><strong>&ldquo;overlay network&rdquo;</strong></em> is a virtual network that runs on top of a different network. Devices in that network are unaware that they are in an overlay. Traditional VPNs, for instance are overlay networks running over Internet.</p>
<p>The term “overlay” has come to be used extensively (instead of VPN) only after technologies different than PPTP or L2TP have been developed to run virtual networks in Cloud environments. For those environments, protocols like VXLAN or GENEVE have been developed to address specific needs.</p>
<p>Connects multiple Docker daemons together to create a flat virtual network across hosts where you can establish communication between a swarm service and a standalone container, or between two standalone containers on different Docker daemons. This strategy removes the need to do OS-level routing between these containers.</p>
<p>This topic includes four different tutorials. You can run each of them on Linux, Windows, or a Mac, but for the last two, you need a second Docker host running elsewhere.</p>
<ul>
<li>
<p>Use the default overlay network demonstrates how to use the default overlay network that Docker sets up for you automatically when you initialize or join a swarm. This network is not the best choice for production systems.</p>
</li>
<li>
<p>Use user-defined overlay networks shows how to create and use your own custom overlay networks, to connect services. This is recommended for services running in production.</p>
</li>
<li>
<p>Use an overlay network for standalone containers shows how to communicate between standalone containers on different Docker daemons using an overlay network.</p>
</li>
<li>
<p>Communicate between a container and a swarm service sets up communication between a standalone container and a swarm service, using an attachable overlay network.</p>
</li>
</ul>
<h4 id=prerequisites>Prerequisites</h4>
<p>These require you to have at least a single-node swarm, which means that you have started Docker and run docker swarm init on the host. You can run the examples on a multi-node swarm as well.</p>
<h4 id=use-the-default-overlay-network>Use the default overlay network</h4>
<p>In this example, you start an alpine service and examine the characteristics of the network from the point of view of the individual service containers.</p>
<p>This tutorial does not go into operation-system-specific details about how overlay networks are implemented, but focuses on how the overlay functions from the point of view of a service.</p>
<h5 id=prerequisites-1>Prerequisites</h5>
<p>This tutorial requires three physical or virtual Docker hosts which can all communicate with one another. This tutorial assumes that the three hosts are running on the same network with no firewall involved.</p>
<p>These hosts will be referred to as <strong>manager</strong>, <strong>worker-1</strong>, and <strong>worker-2</strong>.</p>
<ul>
<li>The <strong>manager host</strong> will function as both a manager and a worker, which means it can both run service tasks and manage the swarm.</li>
<li>worker-1 and worker-2 will function as workers only</li>
</ul>
<p>If you don’t have three hosts handy, an easy solution is to set up three Ubuntu hosts on a cloud provider such as Amazon EC2, all on the same network with all communications allowed to all hosts on that network (using a mechanism such as EC2 security groups), and then to follow the installation instructions for Docker Engine - Community on Ubuntu.</p>
<p>Or you can use Azure, create three VM in the same vnet and same subnet.</p>
<h5 id=walkthrough>Walkthrough</h5>
<h6 id=create-the-swarm>Create the swarm</h6>
<p>At the end of this procedure, all three Docker hosts will be joined to the swarm and will be connected together using an overlay network called <strong>ingress</strong>.</p>
<ol>
<li>On manager. initialize the swarm. If the host only has one network interface, the <strong>&ndash;advertise-addr</strong> flag is optional.</li>
</ol>
<p><strong>Note:</strong>
the &ndash;advertise-addr is the address other nodes in the Docker swarm use to connect into your node. You need to provide an IP address of your host, or a network interface which Docker will use to lookup your IP address, and a port number which defaults to 2377.</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-console data-lang=console><span class=gp>$ </span>docker swarm init --advertise-addr<span class=o>=</span>&lt;IP-ADDRESS-OF-MANAGER&gt;
</code></pre></td></tr></table>
</div>
</div><p>Or</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-console data-lang=console><span class=go>boyang:~$ docker swarm init
</span><span class=go>Swarm initialized: current node (fw5wqlml3lqteplml6l187t1s) is now a manager.
</span><span class=go></span><span class=err>
</span><span class=err></span><span class=go>To add a worker to this swarm, run the following command:
</span><span class=go></span><span class=err>
</span><span class=err></span><span class=go>    docker swarm join --token SWMTKN-1-2hxfhny2wxcp8yzrbb24q7fojsdzmse893tmye19zl7vadvlu5-26jolbhw2yxuzpam991x0k5lt 10.172.0.35:2377
</span><span class=go></span><span class=err>
</span><span class=err></span><span class=go>To add a manager to this swarm, run &#39;docker swarm join-token manager&#39; and follow the instructions.
</span></code></pre></td></tr></table>
</div>
</div><p>Make a note of the text that is printed, as this contains the token that you will use to join <strong>worker-1</strong> and <strong>worker-2</strong> to the swarm. It is a good idea to store the token in a password manager.</p>
<ol start=2>
<li>On worker-1, join the swarm. If the host only has one network interface, the <strong>&ndash;advertise-addr</strong> flag is optional.</li>
</ol>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-console data-lang=console><span class=gp>$ </span>docker swarm join --token &lt;TOKEN&gt; <span class=se>\
</span><span class=se></span><span class=go>  --advertise-addr &lt;IP-ADDRESS-OF-WORKER-1&gt; \
</span><span class=go>  &lt;IP-ADDRESS-OF-MANAGER&gt;:2377
</span></code></pre></td></tr></table>
</div>
</div><ol start=3>
<li>On worker-2, join the swarm. If the host only has one network interface, the &ndash;advertise-addr flag is optional.</li>
</ol>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-console data-lang=console><span class=gp>$ </span>docker swarm join --token &lt;TOKEN&gt; <span class=se>\
</span><span class=se></span><span class=go>  --advertise-addr &lt;IP-ADDRESS-OF-WORKER-2&gt; \
</span><span class=go>  &lt;IP-ADDRESS-OF-MANAGER&gt;:2377
</span></code></pre></td></tr></table>
</div>
</div><ol start=4>
<li>On <strong>manager</strong>, list all the nodes. This command can only be done from a manager.</li>
</ol>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-console data-lang=console><span class=go>boyang:~$ docker node ls
</span><span class=go>ID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS      ENGINE VERSION
</span><span class=go>fw5wqlml3lqteplml6l187t1s *   boyang              Ready               Active              Leader              19.03.13
</span><span class=go>390whrgv9nhjtgsq2egocru59     docker-desktop      Down                Active                                  19.03.13
</span><span class=go>sis0p2wgug8ex4xa894pgilux     docker-desktop      Ready               Active                                  19.03.13
</span></code></pre></td></tr></table>
</div>
</div><p>You can also use the <strong>&ndash;filter</strong> flag to filter by role:</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-console data-lang=console><span class=go>boyang:~$ docker node ls --filter role=manager
</span><span class=go>ID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS      ENGINE VERSION
</span><span class=go>fw5wqlml3lqteplml6l187t1s *   boyang              Ready               Active              Leader              19.03.13
</span></code></pre></td></tr></table>
</div>
</div><div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-console data-lang=console><span class=go>boyang:~$ docker node ls --filter role=worker
</span><span class=go>ID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS      ENGINE VERSION
</span><span class=go>390whrgv9nhjtgsq2egocru59     docker-desktop      Down                Active                                  19.03.13
</span><span class=go>sis0p2wgug8ex4xa894pgilux     docker-desktop      Ready               Active                                  19.03.13
</span></code></pre></td></tr></table>
</div>
</div><ol start=5>
<li>List the Docker networks on <strong>manager</strong>, <strong>worker-1</strong>, and <strong>worker-2</strong> and notice that each of them now has an overlay network called <strong>ingress</strong> and a bridge network called <strong>docker_gwbridge</strong>. Only the listing for manager is shown here:</li>
</ol>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-console data-lang=console><span class=go>boyang:~$ docker network ls
</span><span class=go>NETWORK ID          NAME                                DRIVER              SCOPE
</span><span class=go>a4fcdb4a1130        bridge                              bridge              local
</span><span class=go>cb5178dbb630        docker-as-dev-environment_default   bridge              local
</span><span class=go>67c7f5587624        host                                host                local
</span><span class=go>p8tnia46u002        ingress                             overlay             swarm
</span><span class=go>d15c7dd51668        none                                null                local
</span></code></pre></td></tr></table>
</div>
</div><p>The <strong>docker_gwbridge</strong> connects the <strong>ingress</strong> network to the Docker host’s network interface so that traffic can flow to and from swarm managers and workers. If you create swarm services and do not specify a network, they are connected to the ingress network. It is recommended that you use separate overlay networks for each application or group of applications which will work together. In the next procedure, you will create two overlay networks and connect a service to each of them.</p>
<h6 id=create-the-services>Create the services</h6>
<ol>
<li>On <strong>manager</strong>, create a new overlay network called <strong>nginx-net</strong>:</li>
</ol>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-console data-lang=console><span class=go>boyang:~$ docker network create -d overlay nginx-net
</span><span class=go>zph4h9bddrj0loajnvqyit5q0
</span></code></pre></td></tr></table>
</div>
</div><p>ou don’t need to create the overlay network on the other nodes, because it will be automatically created when one of those nodes starts running a service task which requires it.
2. On manager, create a 5-replica Nginx service connected to nginx-net. The service will publish port 80 to the outside world. All of the service task containers can communicate with each other without opening any ports.
<strong>Note:</strong> Services can only be created on a manager.</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-console data-lang=console><span class=go>boyang:~$ docker service create \
</span><span class=go></span><span class=gp>&gt;   </span>--name my-nginx <span class=se>\
</span><span class=se></span><span class=gp>&gt;   </span>--publish <span class=nv>target</span><span class=o>=</span>80,published<span class=o>=</span><span class=m>80</span> <span class=se>\
</span><span class=se></span><span class=gp>&gt;   </span>--replicas<span class=o>=</span><span class=m>5</span> <span class=se>\
</span><span class=se></span><span class=gp>&gt;   </span>--network nginx-net <span class=se>\
</span><span class=se></span><span class=gp>&gt;   </span>nginx
<span class=go>9cl5n3ja6kbjjwnzuzzsya6hq
</span><span class=go>overall progress: 5 out of 5 tasks 
</span><span class=go>1/5: running   
</span><span class=go>2/5: running   
</span><span class=go>3/5: running   
</span><span class=go>4/5: running   
</span><span class=go>5/5: running   
</span><span class=go>verify: Service converged 
</span></code></pre></td></tr></table>
</div>
</div><p>The default publish mode of <strong>ingress</strong>, which is used when you do not specify a <strong>mode</strong> for the <strong>&ndash;publish</strong> flag, means that if you browse to port 80 on <strong>manager</strong>, <strong>worker-1</strong>, or <strong>worker-2</strong>, you will be connected to port 80 on one of the 5 service tasks, even if no tasks are currently running on the node you browse to. If you want to publish the port using <strong>host</strong> mode, you can add <strong>mode=host</strong> to the <strong>&ndash;publish</strong> output. However, you should also use <strong>&ndash;mode global</strong> instead of <strong>&ndash;replicas=5</strong> in this case, since only one service task can bind a given port on a given node.
3. Run <strong>docker service ls</strong> to monitor the progress of service bring-up, which may take a few seconds.</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-console data-lang=console><span class=go>boyang:~$ docker service ls
</span><span class=go>ID                  NAME                MODE                REPLICAS            IMAGE               PORTS
</span><span class=go>9cl5n3ja6kbj        my-nginx            replicated          5/5                 nginx:latest        *:80-&gt;80/tcp
</span></code></pre></td></tr></table>
</div>
</div><ol start=4>
<li>Inspect the <strong>nginx-net</strong> network on <strong>manager</strong>, <strong>worker-1</strong>, and <strong>worker-2</strong>. Remember that you did not need to create it manually on <strong>worker-1</strong> and <strong>worker-2</strong> because Docker created it for you. The output will be long, but notice the <strong>Containers</strong> and <strong>Peers</strong> sections. <strong>Containers</strong> lists all service tasks (or standalone containers) connected to the overlay network from that host.</li>
<li>From <strong>manager</strong>, inspect the service using <strong>docker service inspect my-nginx</strong> and notice the information about the ports and endpoints used by the service.</li>
<li>Create a new network <strong>nginx-net-2</strong>, then update the service to use this network instead of <strong>nginx-net</strong>:</li>
</ol>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-console data-lang=console><span class=go>boyang:~$ docker network create -d overlay nginx-net-2
</span><span class=go>ceg90igxgtqtp2dpnkq6xhcvf
</span></code></pre></td></tr></table>
</div>
</div><div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>docker service update <span class=se>\
</span><span class=se></span>  --network-add nginx-net-2 <span class=se>\
</span><span class=se></span>  --network-rm nginx-net <span class=se>\
</span><span class=se></span>  my-nginx
</code></pre></td></tr></table>
</div>
</div><ol start=7>
<li>Run <strong>docker service ls</strong> to verify that the service has been updated and all tasks have been redeployed. Run <strong>docker network inspect nginx-net</strong> to verify that no containers are connected to it. Run the same command for <strong>nginx-net-2</strong> and notice that all the service task containers are connected to it.</li>
</ol>
<p><strong>NOTE:</strong> Even though overlay networks are automatically created on swarm worker nodes as needed, they are not automatically removed.</p>
<ol start=8>
<li>Clean up the service and the networks. From <strong>manager</strong>, run the following commands. The manager will direct the workers to remove the networks automatically.</li>
</ol>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>$ docker service rm my-nginx
$ docker network rm nginx-net nginx-net-2
</code></pre></td></tr></table>
</div>
</div><h4 id=use-a-user-defined-overlay-network>Use a user-defined overlay network</h4>
<h5 id=prerequisites-2>Prerequisites</h5>
<p>This tutorial assumes the swarm is already set up and you are on a manager.</p>
<h5 id=walkthrough-1>Walkthrough</h5>
<ol>
<li>Create the user-defined overlay network.</li>
</ol>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>boyang:~$ docker network create -d overlay my-overlay
qf6fthvw6f7dth9ek8x2z9ybf
</code></pre></td></tr></table>
</div>
</div><ol start=2>
<li>Start a service using the overlay network and publishing port 80 to port 8080 on the Docker host.</li>
</ol>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-console data-lang=console><span class=go>boyang:~$ docker service create \
</span><span class=go></span><span class=gp>&gt;   </span>--name my-nginx <span class=se>\
</span><span class=se></span><span class=gp>&gt;   </span>--network my-overlay <span class=se>\
</span><span class=se></span><span class=gp>&gt;   </span>--replicas <span class=m>1</span> <span class=se>\
</span><span class=se></span><span class=gp>&gt;   </span>--publish <span class=nv>published</span><span class=o>=</span>8080,target<span class=o>=</span><span class=m>80</span> <span class=se>\
</span><span class=se></span><span class=gp>&gt;   </span>nginx:latest
<span class=go>222stypuvo2kdfvth4qrntwce
</span><span class=go>overall progress: 1 out of 1 tasks 
</span><span class=go>1/1: running   
</span><span class=go>verify: Service converged 
</span></code></pre></td></tr></table>
</div>
</div><ol start=3>
<li>Run <strong>docker network inspect my-overlay</strong> and verify that the <strong>my-nginx</strong> service task is connected to it, by looking at the <strong>Containers</strong> section.</li>
<li>Remove the service and the network.</li>
</ol>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>$ docker service rm my-nginx

$ docker network rm my-overlay
</code></pre></td></tr></table>
</div>
</div><h4 id=use-an-overlay-network-for-standalone-containers>Use an overlay network for standalone containers</h4>
<p>This example demonstrates DNS container discovery &ndash; specifically, how to communicate between standalone containers on different Docker daemons using an overlay network. Steps are:</p>
<ul>
<li>On host1, initialize the node as a swarm (manager).</li>
<li>On host2, join the node to the swarm (worker).</li>
<li>On host1, create an attachable overlay network (test-net).</li>
<li>On host1, run an interactive alpine container (alpine1) on test-net.</li>
<li>On host2, run an interactive, and detached, alpine container (alpine2) on test-net.</li>
<li>On host1, from within a session of alpine1, ping alpine2.</li>
</ul>
<h5 id=prerequisites-3>Prerequisites</h5>
<p>For this test, you need two different Docker hosts that can communicate with each other. Each host must have the following ports open between the two Docker hosts:</p>
<ul>
<li>TCP port 2377</li>
<li>TCP and UDP port 7946</li>
<li>UDP port 4789
One easy way to set this up is to have two VMs (either local or on a cloud provider like AWS), each with Docker installed and running. If you’re using AWS or a similar cloud computing platform, the easiest configuration is to use a security group that opens all incoming ports between the two hosts and the SSH port from your client’s IP address.</li>
</ul>
<p>This example refers to the two nodes in our swarm as host1 and host2. This example also uses Linux hosts, but the same commands work on Windows.</p>
<h5 id=walk-through>Walk-through</h5>
<ol>
<li>Set up the swarm.
a. On <strong>host1</strong>, initialize a swarm (and if prompted, use <strong>&ndash;advertise-addr</strong> to specify the IP address for the interface that communicates with other hosts in the swarm, for instance, the private IP address on AWS):</li>
</ol>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>docker swarm init
</code></pre></td></tr></table>
</div>
</div><p>b. On <strong>host2</strong>, join the swarm as instructed above:</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>docker swarm join --token &lt;your_token&gt; &lt;your_ip_address&gt;:2377
</code></pre></td></tr></table>
</div>
</div><p>If the node fails to join the swarm, the <strong>docker swarm join</strong> command times out. To resolve, run <strong>docker swarm leave &ndash;force</strong> on <strong>host2</strong>, verify your network and firewall settings, and try again.</p>
<ol start=2>
<li>On <strong>host1</strong>, create an attachable overlay network called <strong>test-net</strong>:</li>
</ol>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-console data-lang=console><span class=go>boyang:~$ docker network create --driver=overlay --attachable test-net
</span><span class=go>94xusd2l3mvr6nt7k5k6d5utj
</span></code></pre></td></tr></table>
</div>
</div><p><strong>Notice</strong> the returned NETWORK ID &ndash; you will see it again when you connect to it from <strong>host2</strong>.
3. On <strong>host1</strong>, start an interactive (<strong>-it</strong>) container (<strong>alpine1</strong>) that connects to <strong>test-net</strong>:</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>docker run -it --name alpine1 --network test-net alpine
</code></pre></td></tr></table>
</div>
</div><p><strong>NOTE:</strong> If you faing &ldquo;docker unable to enable skip dnat rule&rdquo;, please <strong>sudo systemctl restart docker</strong></p>
<ol start=4>
<li>On <strong>host2</strong>, list the available networks &ndash; notice that <strong>test-net</strong> does not yet exist:</li>
</ol>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>docker network ls
</code></pre></td></tr></table>
</div>
</div><ol start=5>
<li>On <strong>host2</strong>, start a detached (<strong>-d</strong>) and interactive (<strong>-it</strong>) container (<strong>alpine2</strong>) that connects to <strong>test-net</strong>:</li>
</ol>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>docker run -dit --name alpine2 --network test-net alpine
</code></pre></td></tr></table>
</div>
</div><p><strong>NOTE:</strong> Automatic DNS container discovery only works with unique container names.</p>
<ol start=6>
<li>On <strong>host2</strong>, verify that <strong>test-net</strong> was created (and has the same NETWORK ID as <strong>test-net</strong> on <strong>host1</strong>):</li>
</ol>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>docker network ls
</code></pre></td></tr></table>
</div>
</div><ol start=7>
<li>On <strong>host1</strong>, ping <strong>alpine2</strong> within the interactive terminal of <strong>alpine1</strong>:</li>
</ol>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>ping -c <span class=m>2</span> alpine2
</code></pre></td></tr></table>
</div>
</div><p>The two containers communicate with the overlay network connecting the two hosts. If you run another alpine container on host2 that is not detached, you can ping alpine1 from host2 (and here we add the remove option for automatic container cleanup):</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>docker run -it --rm --name alpine3 --network test-net alpine
</code></pre></td></tr></table>
</div>
</div><ol start=8>
<li>On host1, close the alpine1 session (which also stops the container):</li>
</ol>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-console data-lang=console><span class=go>/ # exit
</span></code></pre></td></tr></table>
</div>
</div><ol start=9>
<li>Clean up your containers and networks:</li>
</ol>
<p>You must stop and remove the containers on each host independently because Docker daemons operate independently and these are standalone containers. You only have to remove the network on host1 because when you stop alpine2 on host2, test-net disappears.</p>
<p>a. On host2, stop alpine2, check that test-net was removed, then remove alpine2:</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>docker container stop alpine2
docker network ls
docker container rm alpine2
</code></pre></td></tr></table>
</div>
</div><p>a. On host1, remove alpine1 and test-net:</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>$ docker container rm alpine1
$ docker network rm test-net
</code></pre></td></tr></table>
</div>
</div><h4 id=communicate-between-a-container-and-a-swarm-service>Communicate between a container and a swarm service</h4>
<p>In this example, you start two different alpine containers on the same Docker host and do some tests to understand how they communicate with each other. You need to have Docker installed and running.</p>
<ol>
<li>Open a terminal window. List current networks before you do anything else. Here’s what you should see if you’ve never added a network or initialized a swarm on this Docker daemon. You may see different networks, but you should at least see these (the network IDs will be different):</li>
</ol>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-console data-lang=console><span class=gp>$ </span>docker network ls
<span class=err>
</span><span class=err></span><span class=go>NETWORK ID          NAME                DRIVER              SCOPE
</span><span class=go>17e324f45964        bridge              bridge              local
</span><span class=go>6ed54d316334        host                host                local
</span><span class=go>7092879f2cc8        none                null                local
</span></code></pre></td></tr></table>
</div>
</div><p>The default <strong>bridge</strong> network is listed, along with <strong>host</strong> and <strong>none</strong>. The latter two are not fully-fledged networks, but are used to start a container connected directly to the Docker daemon host’s networking stack, or to start a container with no network devices. This tutorial will connect two containers to the bridge network.</p>
<ol start=2>
<li>Start two <strong>alpine</strong> containers running <strong>ash</strong>, which is Alpine’s default shell rather than <strong>bash</strong>. The <strong>-dit</strong> flags mean to start the container detached (in the background), interactive (with the ability to type into it), and with a TTY (so you can see the input and output). Since you are starting it detached, you won’t be connected to the container right away. Instead, the container’s ID will be printed. Because you have not specified any <strong>&ndash;network</strong> flags, the containers connect to the default <strong>bridge</strong> network.</li>
</ol>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>$ docker run -dit --name alpine1 alpine ash

$ docker run -dit --name alpine2 alpine ash
</code></pre></td></tr></table>
</div>
</div><p>Check that both containers are actually started:</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-console data-lang=console><span class=go>boyang:~$ docker container ls
</span><span class=go>CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
</span><span class=go>289df352d7a5        alpine              &#34;ash&#34;               9 seconds ago       Up 8 seconds                            alpine2
</span><span class=go>f290d44a25c0        alpine              &#34;ash&#34;               21 seconds ago      Up 21 seconds                           alpine1
</span></code></pre></td></tr></table>
</div>
</div><ol start=3>
<li>Inspect the <strong>bridge</strong> network to see what containers are connected to it.</li>
</ol>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-console data-lang=console><span class=go>boyang:~$ docker network inspect bridge
</span><span class=go>[
</span><span class=go>    {
</span><span class=go>        &#34;Name&#34;: &#34;bridge&#34;,
</span><span class=go>        &#34;Id&#34;: &#34;26457e3bc6552ecfe3a0ccee3f49dcdf729895551253cd2e1a20409794b7c664&#34;,
</span><span class=go>        &#34;Created&#34;: &#34;2020-12-02T14:30:59.20531188+08:00&#34;,
</span><span class=go>        &#34;Scope&#34;: &#34;local&#34;,
</span><span class=go>        &#34;Driver&#34;: &#34;bridge&#34;,
</span><span class=go>        &#34;EnableIPv6&#34;: false,
</span><span class=go>        &#34;IPAM&#34;: {
</span><span class=go>            &#34;Driver&#34;: &#34;default&#34;,
</span><span class=go>            &#34;Options&#34;: null,
</span><span class=go>            &#34;Config&#34;: [
</span><span class=go>                {
</span><span class=go>                    &#34;Subnet&#34;: &#34;172.17.0.0/16&#34;,
</span><span class=go>                    &#34;Gateway&#34;: &#34;172.17.0.1&#34;
</span><span class=go>                }
</span><span class=go>            ]
</span><span class=go>        },
</span><span class=go>        &#34;Internal&#34;: false,
</span><span class=go>        &#34;Attachable&#34;: false,
</span><span class=go>        &#34;Ingress&#34;: false,
</span><span class=go>        &#34;ConfigFrom&#34;: {
</span><span class=go>            &#34;Network&#34;: &#34;&#34;
</span><span class=go>        },
</span><span class=go>        &#34;ConfigOnly&#34;: false,
</span><span class=go>        &#34;Containers&#34;: {
</span><span class=go>            &#34;289df352d7a5420a0976ff3580ad375833d8d507ff65de801966e58fcc6ecd67&#34;: {
</span><span class=go>                &#34;Name&#34;: &#34;alpine2&#34;,
</span><span class=go>                &#34;EndpointID&#34;: &#34;99efbc2b3657fc2d92c91760f1d2bb2eabc3760fcf3e8ccefef89537d9faea67&#34;,
</span><span class=go>                &#34;MacAddress&#34;: &#34;02:42:ac:11:00:03&#34;,
</span><span class=go>                &#34;IPv4Address&#34;: &#34;172.17.0.3/16&#34;,
</span><span class=go>                &#34;IPv6Address&#34;: &#34;&#34;
</span><span class=go>            },
</span><span class=go>            &#34;f290d44a25c05ce1940ab72c49d5be2bdfe16f2780624f3968b6e1fdfa4f91ab&#34;: {
</span><span class=go>                &#34;Name&#34;: &#34;alpine1&#34;,
</span><span class=go>                &#34;EndpointID&#34;: &#34;d210fe84902f4278188257074f5be4d0e6dab86baac146a4067af415734a01a5&#34;,
</span><span class=go>                &#34;MacAddress&#34;: &#34;02:42:ac:11:00:02&#34;,
</span><span class=go>                &#34;IPv4Address&#34;: &#34;172.17.0.2/16&#34;,
</span><span class=go>                &#34;IPv6Address&#34;: &#34;&#34;
</span><span class=go>            }
</span><span class=go>        },
</span><span class=go>        &#34;Options&#34;: {
</span><span class=go>            &#34;com.docker.network.bridge.default_bridge&#34;: &#34;true&#34;,
</span><span class=go>            &#34;com.docker.network.bridge.enable_icc&#34;: &#34;true&#34;,
</span><span class=go>            &#34;com.docker.network.bridge.enable_ip_masquerade&#34;: &#34;true&#34;,
</span><span class=go>            &#34;com.docker.network.bridge.host_binding_ipv4&#34;: &#34;0.0.0.0&#34;,
</span><span class=go>            &#34;com.docker.network.bridge.name&#34;: &#34;docker0&#34;,
</span><span class=go>            &#34;com.docker.network.driver.mtu&#34;: &#34;1500&#34;
</span><span class=go>        },
</span><span class=go>        &#34;Labels&#34;: {}
</span><span class=go>    }
</span><span class=go>]
</span></code></pre></td></tr></table>
</div>
</div><p>Near the top, information about the <strong>bridge</strong> network is listed, including the IP address of the gateway between the Docker host and the <strong>bridge</strong> network (<strong>172.17.0.1</strong>). Under the <strong>Containers</strong> key, each connected container is listed, along with information about its IP address (<strong>172.17.0.2</strong> for <strong>alpine1</strong> and <strong>172.17.0.3</strong> for <strong>alpine2</strong>).</p>
<ol start=4>
<li>The containers are running in the background. Use the <strong>docker attach</strong> command to connect to <strong>alpine1</strong>.</li>
</ol>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-console data-lang=console><span class=go>boyang:~$ docker attach alpine1
</span><span class=go>/ # 
</span></code></pre></td></tr></table>
</div>
</div><p>The prompt changes to <strong>#</strong> to indicate that you are the <strong>root</strong> user within the container. Use the <strong>ip addr show</strong> command to show the network interfaces for <strong>alpine1</strong> as they look from within the container:</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-console data-lang=console><span class=gp>#</span><span class=c1># ip addr show</span>
<span class=go>1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1000
</span><span class=go>    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
</span><span class=go>    inet 127.0.0.1/8 scope host lo
</span><span class=go>       valid_lft forever preferred_lft forever
</span><span class=go>6024: eth0@if6025: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue state UP 
</span><span class=go>    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff
</span><span class=go>    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0
</span><span class=go>       valid_lft forever preferred_lft forever
</span></code></pre></td></tr></table>
</div>
</div><p>The first interface is the loopback device. Ignore it for now. Notice that the second interface has the IP address <strong>172.17.0.2</strong>, which is the same address shown for <strong>alpine1</strong> in the previous step.</p>
<ol start=5>
<li>From within <strong>alpine1</strong>, make sure you can connect to the internet by pinging <strong>google.com</strong>. The <strong>-c 2</strong> flag limits the command two two <strong>ping</strong> attempts.</li>
</ol>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-console data-lang=console><span class=gp>#</span><span class=c1># ping -c 2 google.com</span>
<span class=go>PING google.com (172.217.194.113): 56 data bytes
</span><span class=go>64 bytes from 172.217.194.113: seq=0 ttl=49 time=60.069 ms
</span><span class=go>64 bytes from 172.217.194.113: seq=1 ttl=49 time=60.103 ms
</span><span class=go></span><span class=err>
</span><span class=err></span><span class=go>--- google.com ping statistics ---
</span><span class=go>2 packets transmitted, 2 packets received, 0% packet loss
</span><span class=go>round-trip min/avg/max = 60.069/60.086/60.103 ms
</span></code></pre></td></tr></table>
</div>
</div><ol start=6>
<li>Now try to ping the second container. First, ping it by its IP address, <strong>172.17.0.3</strong>:</li>
</ol>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-console data-lang=console><span class=gp>#</span><span class=c1># ping -c 2 172.17.0.3</span>
<span class=go>PING 172.17.0.3 (172.17.0.3): 56 data bytes
</span><span class=go>64 bytes from 172.17.0.3: seq=0 ttl=64 time=0.058 ms
</span><span class=go>64 bytes from 172.17.0.3: seq=1 ttl=64 time=0.131 ms
</span><span class=go></span><span class=err>
</span><span class=err></span><span class=go>--- 172.17.0.3 ping statistics ---
</span><span class=go>2 packets transmitted, 2 packets received, 0% packet loss
</span><span class=go>round-trip min/avg/max = 0.058/0.094/0.131 ms
</span></code></pre></td></tr></table>
</div>
</div><p>This succeeds. Next, try pinging the <strong>alpine2</strong> container by container name. This will fail.</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-console data-lang=console><span class=gp>#</span><span class=c1># ping -c 2 alpine2</span>
<span class=go>ping: bad address &#39;alpine2&#39;
</span></code></pre></td></tr></table>
</div>
</div><ol start=7>
<li>
<p>Detach from <strong>alpine1</strong> without stopping it by using the detach sequence, <strong>CTRL + p</strong> **CTRL + q **(hold down CTRL and type p followed by q). If you wish, attach to <strong>alpine2</strong> and repeat steps 4, 5, and 6 there, substituting <strong>alpine1</strong> for <strong>alpine2</strong>.</p>
</li>
<li>
<p>Stop and remove both containers.</p>
</li>
</ol>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>$ docker container stop alpine1 alpine2
$ docker container rm alpine1 alpine2
</code></pre></td></tr></table>
</div>
</div><p><strong>Remember</strong>, the default bridge network is not recommended for production.</p>
<h3 id=macvlan>Macvlan</h3>
<p>Macvlan networks allow you to assign a MAC address to a container, making it appear as a physical device on your network. The Docker daemon routes traffic to containers by their MAC addresses. Using the macvlan driver is sometimes the best choice when dealing with legacy applications that expect to be directly connected to the physical network, rather than routed through the Docker host’s network stack.</p>
<p>Some applications, especially legacy applications or applications which monitor network traffic, expect to be directly connected to the physical network. In this type of situation, you can use the macvlan network driver to assign a MAC address to each container’s virtual network interface, making it appear to be a physical network interface directly connected to the physical network. In this case, you need to designate a physical interface on your Docker host to use for the macvlan, as well as the subnet and gateway of the macvlan. You can even isolate your macvlan networks using different physical network interfaces. Keep the following things in mind:</p>
<ul>
<li>
<p>It is very easy to unintentionally damage your network due to IP address exhaustion or to “VLAN spread”, which is a situation in which you have an inappropriately large number of unique MAC addresses in your network.</p>
</li>
<li>
<p>Your networking equipment needs to be able to handle “promiscuous mode”, where one physical interface can be assigned multiple MAC addresses.</p>
</li>
<li>
<p>If your application can work using a bridge (on a single Docker host) or overlay (to communicate across multiple Docker hosts), these solutions may be better in the long term.</p>
</li>
</ul>
<h4 id=create-a-macvlan-network>Create a macvlan network</h4>
<p>When you create a macvlan network, it can either be in bridge mode or 802.1q trunk bridge mode.</p>
<ul>
<li>
<p>In bridge mode, macvlan traffic goes through a physical device on the host.</p>
</li>
<li>
<p>In 802.1q trunk bridge mode, traffic goes through an 802.1q sub-interface which Docker creates on the fly. This allows you to control routing and filtering at a more granular level.</p>
</li>
</ul>
<h5 id=bridge-mode>Bridge mode</h5>
<p>To create a macvlan network which bridges with a given physical network interface, use &ndash;driver macvlan with the docker network create command. You also need to specify the parent, which is the interface the traffic will physically go through on the Docker host.</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-console data-lang=console><span class=gp>$ </span>docker network create -d macvlan <span class=se>\
</span><span class=se></span><span class=go>  --subnet=172.16.86.0/24 \
</span><span class=go>  --gateway=172.16.86.1 \
</span><span class=go>  -o parent=eth0 pub_net
</span></code></pre></td></tr></table>
</div>
</div><p>If you need to exclude IP addresses from being used in the macvlan network, such as when a given IP address is already in use, use &ndash;aux-addresses:</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-console data-lang=console><span class=gp>$ </span>docker network create -d macvlan <span class=se>\
</span><span class=se></span><span class=go>  --subnet=192.168.32.0/24 \
</span><span class=go>  --ip-range=192.168.32.128/25 \
</span><span class=go>  --gateway=192.168.32.254 \
</span><span class=go>  --aux-address=&#34;my-router=192.168.32.129&#34; \
</span><span class=go>  -o parent=eth0 macnet32
</span></code></pre></td></tr></table>
</div>
</div><h5 id=8021q-trunk-bridge-mode>802.1q trunk bridge mode</h5>
<p>If you specify a parent interface name with a dot included, such as eth0.50, Docker interprets that as a sub-interface of eth0 and creates the sub-interface automatically.</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-console data-lang=console><span class=gp>$ </span>docker network create -d macvlan <span class=se>\
</span><span class=se></span><span class=go>    --subnet=192.168.50.0/24 \
</span><span class=go>    --gateway=192.168.50.1 \
</span><span class=go>    -o parent=eth0.50 macvlan50
</span></code></pre></td></tr></table>
</div>
</div><h5 id=use-an-ipvlan-instead-of-macvlan>Use an ipvlan instead of macvlan</h5>
<p>In the above example, you are still using a L3 bridge. You can use ipvlan instead, and get an L2 bridge. Specify -o ipvlan_mode=l2.</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-console data-lang=console><span class=gp>$ </span>docker network create -d ipvlan <span class=se>\
</span><span class=se></span><span class=go>    --subnet=192.168.210.0/24 \
</span><span class=go>    --subnet=192.168.212.0/24 \
</span><span class=go>    --gateway=192.168.210.254 \
</span><span class=go>    --gateway=192.168.212.254 \
</span><span class=go>     -o ipvlan_mode=l2 ipvlan210
</span></code></pre></td></tr></table>
</div>
</div><h5 id=use-ipv6-1>Use IPv6</h5>
<p>If you have configured the Docker daemon to allow IPv6, you can use dual-stack IPv4/IPv6 macvlan networks.</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-console data-lang=console><span class=gp>$ </span>docker network create -d macvlan <span class=se>\
</span><span class=se></span><span class=go>    --subnet=192.168.216.0/24 --subnet=192.168.218.0/24 \
</span><span class=go>    --gateway=192.168.216.1 --gateway=192.168.218.1 \
</span><span class=go>    --subnet=2001:db8:abc8::/64 --gateway=2001:db8:abc8::10 \
</span><span class=go>     -o parent=eth0.218 \
</span><span class=go>     -o macvlan_mode=bridge macvlan216
</span></code></pre></td></tr></table>
</div>
</div><h3 id=none>None</h3>
<p>For this container, disable all networking. Usually used in conjunction with a custom network driver. none is not available for swarm services. See disable container networking.</p>
<h3 id=network-plugins>Network plugins</h3>
<p>You can install and use third-party network plugins with Docker. These plugins are available from Docker Hub or from third-party vendors. See the vendor’s documentation for installing and using a given network plugin.</p>
</div><div class=post-footer id=post-footer>
<div class=post-info>
<div class=post-info-line>
<div class=post-info-mod>
<span>Updated on 2021-12-12</span>
</div>
<div class=post-info-license></div>
</div>
<div class=post-info-line>
<div class=post-info-md><span>
<a class=link-to-markdown href=https://yanboyang.com/dockernetworking/index.md target=_blank rel="noopener noreferrer">Read Markdown</a>
</span></div>
<div class=post-info-share>
<span><a href=javascript:void(0); title="Share on Twitter" data-sharer=twitter data-url=https://yanboyang.com/dockernetworking/ data-title="Getting started with Docker Networking" data-hashtags=Docker,Networking><i class="fab fa-twitter fa-fw"></i></a><a href=javascript:void(0); title="Share on Facebook" data-sharer=facebook data-url=https://yanboyang.com/dockernetworking/ data-hashtag=Docker><i class="fab fa-facebook-square fa-fw"></i></a><a href=javascript:void(0); title="Share on WhatsApp" data-sharer=whatsapp data-url=https://yanboyang.com/dockernetworking/ data-title="Getting started with Docker Networking" data-web><i class="fab fa-whatsapp fa-fw"></i></a><a href=javascript:void(0); title="Share on Line" data-sharer=line data-url=https://yanboyang.com/dockernetworking/ data-title="Getting started with Docker Networking"><i data-svg-src=https://yanboyang.com/lib/simple-icons/icons/line.min.svg></i></a><a href=javascript:void(0); title="Share on 微博" data-sharer=weibo data-url=https://yanboyang.com/dockernetworking/ data-title="Getting started with Docker Networking"><i class="fab fa-weibo fa-fw"></i></a><a href=javascript:void(0); title="Share on Myspace" data-sharer=myspace data-url=https://yanboyang.com/dockernetworking/ data-title="Getting started with Docker Networking" data-description><i data-svg-src=https://yanboyang.com/lib/simple-icons/icons/myspace.min.svg></i></a><a href=javascript:void(0); title="Share on Blogger" data-sharer=blogger data-url=https://yanboyang.com/dockernetworking/ data-title="Getting started with Docker Networking" data-description><i class="fab fa-blogger fa-fw"></i></a><a href=javascript:void(0); title="Share on Evernote" data-sharer=evernote data-url=https://yanboyang.com/dockernetworking/ data-title="Getting started with Docker Networking"><i class="fab fa-evernote fa-fw"></i></a></span>
</div>
</div>
</div>
<div class=post-info-more>
<section class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=https://yanboyang.com/tags/docker/>Docker</a>,&nbsp;<a href=https://yanboyang.com/tags/networking/>Networking</a></section>
<section>
<span><a href=javascript:void(0); onclick=window.history.back()>Back</a></span>&nbsp;|&nbsp;<span><a href=https://yanboyang.com/>Home</a></span>
</section>
</div>
<div class=post-nav><a href=https://yanboyang.com/wechat/ class=prev rel=prev title="Installing Wechat Desktop Client in Ubuntu Linux"><i class="fas fa-angle-left fa-fw"></i>Installing Wechat Desktop Client in Ubuntu Linux</a>
<a href=https://yanboyang.com/acr/ class=next rel=next title="Getting started with Azure Container Registry (ACR)">Getting started with Azure Container Registry (ACR)<i class="fas fa-angle-right fa-fw"></i></a></div>
</div>
<div id=comments><div id=disqus_thread class=comment></div><noscript>
Please enable JavaScript to view the comments powered by <a href=https://disqus.com/?ref_noscript>Disqus</a>.
</noscript></div></article></div>
</main><footer class=footer>
<div class=footer-container><div class=footer-line>Powered by <a href=https://gohugo.io/ target=_blank rel="noopener noreferrer" title="Hugo 0.90.1">Hugo</a> | Theme - <a href=https://github.com/sunt-programator/CodeIT target=_blank rel="noopener noreferrer" title="CodeIT 0.2.10"><i class="fas fa-laptop-code fa-fw"></i> CodeIT</a>
</div><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2019 - 2021</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://yanboyang.com/ target=_blank rel="noopener noreferrer">Boyang Yan</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div>
</div>
</footer></div>
<div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title="Back to Top">
<i class="fas fa-arrow-up fa-fw"></i>
</a><a href=# id=view-comments class=fixed-button title="View Comments">
<i class="fas fa-comment fa-fw"></i>
</a>
</div><link rel=stylesheet href=https://yanboyang.com/lib/katex/katex.min.css><link rel=stylesheet href=https://yanboyang.com/lib/katex/copy-tex.min.css><link rel=stylesheet href=https://yanboyang.com/lib/cookieconsent/cookieconsent.min.css><script type=text/javascript src=https://boyang-blog.disqus.com/embed.js defer></script><script type=text/javascript src=https://yanboyang.com/lib/smooth-scroll/smooth-scroll.min.js></script><script type=text/javascript src=https://yanboyang.com/lib/autocomplete/autocomplete.min.js></script><script type=text/javascript src=https://yanboyang.com/lib/lunr/lunr.min.js></script><script type=text/javascript src=https://yanboyang.com/lib/lazysizes/lazysizes.min.js></script><script type=text/javascript src=https://yanboyang.com/lib/clipboard/clipboard.min.js></script><script type=text/javascript src=https://yanboyang.com/lib/sharer/sharer.min.js></script><script type=text/javascript src=https://yanboyang.com/lib/katex/katex.min.js></script><script type=text/javascript src=https://yanboyang.com/lib/katex/auto-render.min.js></script><script type=text/javascript src=https://yanboyang.com/lib/katex/copy-tex.min.js></script><script type=text/javascript src=https://yanboyang.com/lib/katex/mhchem.min.js></script><script type=text/javascript src=https://yanboyang.com/lib/cookieconsent/cookieconsent.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"Copy to clipboard",maxShownLines:1e3},comment:{},cookieconsent:{content:{dismiss:"Got it!",link:"Learn more",message:"This website uses Cookies to improve your experience."},enable:!0,palette:{button:{background:"#f0f0f0"},popup:{background:"#1aa3ff"}},theme:"edgeless"},math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{highlightTag:"em",lunrIndexURL:"/index.json",maxResultLength:10,noResultsFound:"No results found",snippetLength:30,type:"lunr"}}</script><script type=text/javascript src=https://yanboyang.com/js/theme.min.js></script></body>
</html>